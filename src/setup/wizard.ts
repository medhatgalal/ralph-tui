/**
 * ABOUTME: Interactive setup wizard for Ralph TUI.
 * Guides users through initial configuration when no .ralph-tui/config.toml exists.
 * Detects available plugins and collects tracker/agent preferences.
 */

import { access, constants, writeFile, mkdir } from 'node:fs/promises';
import { join } from 'node:path';
import { stringify as stringifyToml } from 'smol-toml';
import { getTrackerRegistry } from '../plugins/trackers/registry.js';
import { getAgentRegistry } from '../plugins/agents/registry.js';
import { registerBuiltinTrackers } from '../plugins/trackers/builtin/index.js';
import { registerBuiltinAgents } from '../plugins/agents/builtin/index.js';
import type { StoredConfig } from '../config/types.js';
import type {
  SetupResult,
  SetupOptions,
  SetupAnswers,
  PluginDetection,
} from './types.js';
import {
  promptSelect,
  promptNumber,
  promptBoolean,
  promptQuestion,
  printSection,
  printSuccess,
  printInfo,
  printError,
} from './prompts.js';
import {
  listBundledSkills,
  installSkillsForAgent,
  isSkillInstalled,
} from './skill-installer.js';
import { CURRENT_CONFIG_VERSION } from './migration.js';

/**
 * Config directory and filename
 */
const CONFIG_DIR = '.ralph-tui';
const CONFIG_FILENAME = 'config.toml';

/**
 * Check if a project config file exists
 */
export async function projectConfigExists(cwd: string = process.cwd()): Promise<boolean> {
  const configPath = join(cwd, CONFIG_DIR, CONFIG_FILENAME);
  try {
    await access(configPath, constants.R_OK);
    return true;
  } catch {
    return false;
  }
}

/**
 * Detect available tracker plugins
 */
async function detectTrackerPlugins(): Promise<PluginDetection[]> {
  const registry = getTrackerRegistry();

  // Register built-in plugins if not already done
  registerBuiltinTrackers();
  await registry.initialize();

  const plugins = registry.getRegisteredPlugins();
  const detections: PluginDetection[] = [];

  for (const meta of plugins) {
    const instance = registry.createInstance(meta.id);
    if (!instance) continue;

    // For trackers, we can't really "detect" without config
    // So we just list them as available
    detections.push({
      id: meta.id,
      name: meta.name,
      description: meta.description,
      available: true,
      version: meta.version,
    });

    await instance.dispose();
  }

  return detections;
}

/**
 * Detect available agent plugins with CLI availability
 */
async function detectAgentPlugins(): Promise<PluginDetection[]> {
  const registry = getAgentRegistry();

  // Register built-in plugins if not already done
  registerBuiltinAgents();
  await registry.initialize();

  const plugins = registry.getRegisteredPlugins();
  const detections: PluginDetection[] = [];

  for (const meta of plugins) {
    const instance = registry.createInstance(meta.id);
    if (!instance) continue;

    // Initialize with empty config to enable detection
    await instance.initialize({});

    // Detect if CLI is available
    const detectResult = await instance.detect();

    detections.push({
      id: meta.id,
      name: meta.name,
      description: meta.description,
      available: detectResult.available,
      version: detectResult.version,
      error: detectResult.error,
    });

    await instance.dispose();
  }

  return detections;
}

/**
 * Collect tracker-specific options via setup questions
 */
async function collectTrackerOptions(
  trackerId: string
): Promise<Record<string, unknown>> {
  const registry = getTrackerRegistry();
  const instance = registry.createInstance(trackerId);
  if (!instance) {
    return {};
  }

  const questions = instance.getSetupQuestions();
  await instance.dispose();

  if (questions.length === 0) {
    return {};
  }

  printSection('Tracker Configuration');
  printInfo(`Configure the ${trackerId} tracker:`);
  console.log();

  const options: Record<string, unknown> = {};

  for (const question of questions) {
    options[question.id] = await promptQuestion(question);
  }

  return options;
}

/**
 * Save configuration to .ralph-tui/config.toml
 */
async function saveConfig(
  answers: SetupAnswers,
  cwd: string
): Promise<string> {
  const configDir = join(cwd, CONFIG_DIR);
  const configPath = join(configDir, CONFIG_FILENAME);

  // Ensure .ralph-tui directory exists
  await mkdir(configDir, { recursive: true });

  // Build StoredConfig from answers
  const config: StoredConfig = {
    // Config version for future migrations
    configVersion: CURRENT_CONFIG_VERSION,
    // Use shorthand format for simpler config
    tracker: answers.tracker,
    trackerOptions: answers.trackerOptions,
    agent: answers.agent,
    agentOptions: answers.agentOptions,
    maxIterations: answers.maxIterations,
    autoCommit: answers.autoCommit,
  };

  // Serialize to TOML
  const toml = stringifyToml(config);

  // Add header comment
  const content = `# Ralph TUI Configuration
# Generated by setup wizard
# See: ralph-tui config help

${toml}`;

  await writeFile(configPath, content, 'utf-8');

  return configPath;
}

/**
 * Run the interactive setup wizard
 */
export async function runSetupWizard(
  options: SetupOptions = {}
): Promise<SetupResult> {
  const cwd = options.cwd ?? process.cwd();

  try {
    // Check if config already exists
    if (!options.force) {
      const exists = await projectConfigExists(cwd);
      if (exists) {
        return {
          success: false,
          error: `Configuration file already exists: ${join(cwd, CONFIG_DIR, CONFIG_FILENAME)}. Use --force to overwrite.`,
        };
      }
    }

    // Print welcome banner
    console.log();
    console.log('╔════════════════════════════════════════════════════════════╗');
    console.log('║                   Ralph TUI Setup Wizard                    ║');
    console.log('╚════════════════════════════════════════════════════════════╝');
    console.log();
    printInfo('This wizard will help you configure Ralph TUI for your project.');
    printInfo('Press Ctrl+C at any time to cancel.');

    // === Step 1: Select Tracker ===
    printSection('Issue Tracker Selection');

    const trackerPlugins = await detectTrackerPlugins();
    if (trackerPlugins.length === 0) {
      return {
        success: false,
        error: 'No tracker plugins available. Please install a tracker plugin.',
      };
    }

    // Build choices with availability info
    const trackerChoices = trackerPlugins.map((p) => ({
      value: p.id,
      label: p.name,
      description: p.available
        ? p.description
        : `${p.description} (not available: ${p.error})`,
    }));

    const selectedTracker = await promptSelect(
      'Which issue tracker do you want to use?',
      trackerChoices,
      {
        default: trackerPlugins.find((p) => p.available)?.id,
        help: 'Ralph will use this tracker to manage tasks.',
      }
    );

    // Collect tracker-specific options
    const trackerOptions = await collectTrackerOptions(selectedTracker);

    // === Step 2: Select Agent ===
    printSection('Agent CLI Selection');

    const agentPlugins = await detectAgentPlugins();
    
    // Filter to only available agents
    const availableAgents = agentPlugins.filter((p) => p.available);
    
    if (availableAgents.length === 0) {
      printError('No AI coding agents detected on your system.');
      printInfo('Ralph TUI supports: Claude Code, Gemini CLI, Codex, Kiro CLI, OpenCode, Factory Droid');
      printInfo('Please install at least one supported agent and try again.');
      return {
        success: false,
        error: 'No AI coding agents detected. Install Claude Code, Gemini CLI, Codex, or Kiro CLI.',
      };
    }

    // Build choices from available agents only
    const agentChoices = availableAgents.map((p) => ({
      value: p.id,
      label: `${p.name} (v${p.version})`,
      description: p.description,
    }));

    // Default to first available agent
    const defaultAgent = availableAgents[0]?.id;

    printInfo('Ralph supports multiple AI coding agents.');
    printSuccess(`Detected ${availableAgents.length} agent(s): ${availableAgents.map(a => a.name).join(', ')}`);
    console.log();

    const selectedAgent = await promptSelect(
      'Which agent CLI do you want to use?',
      agentChoices,
      {
        default: defaultAgent,
        help: 'The AI agent that will execute coding tasks.',
      }
    );

    // Collect agent-specific options (skip for default setup)
    // For simplicity, we'll skip agent-specific options in the wizard
    // They can be configured later via config file
    const agentOptions: Record<string, unknown> = {};

    // === Step 3: Iteration Settings ===
    printSection('Iteration Settings');

    const maxIterations = await promptNumber(
      'Maximum iterations per run?',
      {
        default: 10,
        min: 0,
        max: 1000,
        help: 'How many tasks to process before stopping (0 = unlimited).',
      }
    );

    const autoCommit = await promptBoolean(
      'Auto-commit on task completion?',
      {
        default: false,
        help: 'Automatically commit changes after each successful task.',
      }
    );

    // === Step 4: Skills Installation ===
    printSection('AI Skills Installation');

    const bundledSkills = await listBundledSkills();
    
    // Get agent registry for skill installation
    const skillsAgentRegistry = getAgentRegistry();
    
    // Get agents with skillsPaths defined
    const agentsWithSkills = availableAgents.filter(p => {
      const instance = skillsAgentRegistry.createInstance(p.id);
      const hasSkills = instance?.meta.skillsPaths !== undefined;
      instance?.dispose();
      return hasSkills;
    });
    
    // Determine which agents to install skills for
    let targetAgentIds: string[] = [selectedAgent];
    
    if (bundledSkills.length > 0 && agentsWithSkills.length > 1) {
      // Multiple agents with skills support - ask user which to install for
      printInfo('Ralph TUI includes AI skills that enhance agent capabilities.');
      printInfo(`Agents with skill support: ${agentsWithSkills.map(a => a.name).join(', ')}`);
      console.log();
      
      const skillInstallChoice = await promptSelect(
        'Install skills for which agent(s)?',
        [
          { value: 'selected', label: `${selectedAgent} only`, description: 'Install skills for your selected agent' },
          { value: 'all', label: 'All detected agents', description: `Install skills for: ${agentsWithSkills.map(a => a.id).join(', ')}` },
          { value: 'none', label: 'Skip skill installation', description: 'You can install skills later with: ralph-tui skill install' },
        ],
        {
          default: 'selected',
          help: 'Skills enable using ralph-tui capabilities directly inside each agent.',
        }
      );
      
      if (skillInstallChoice === 'all') {
        targetAgentIds = agentsWithSkills.map(a => a.id);
      } else if (skillInstallChoice === 'none') {
        targetAgentIds = [];
      }
    } else if (bundledSkills.length > 0) {
      // Single agent or no multi-agent choice needed
      printInfo('Ralph TUI includes AI skills that enhance agent capabilities.');
      console.log();
    }

    // Install skills to target agents using the new API
    if (targetAgentIds.length > 0 && bundledSkills.length > 0) {
      for (const agentId of targetAgentIds) {
        const instance = skillsAgentRegistry.createInstance(agentId);
        if (!instance?.meta.skillsPaths) continue;
        
        const agentMeta = availableAgents.find(a => a.id === agentId);
        const agentName = agentMeta?.name ?? agentId;
        
        // For single agent, ask per-skill; for multiple, install all
        if (targetAgentIds.length === 1) {
          for (const skill of bundledSkills) {
            const alreadyInstalled = await isSkillInstalled(skill.name);
            const actionLabel = alreadyInstalled ? 'Update' : 'Install';
            
            const installThisSkill = await promptBoolean(
              `${actionLabel} skill: ${skill.name}?`,
              { default: true, help: skill.description }
            );
            
            if (installThisSkill) {
              const result = await installSkillsForAgent(
                agentId,
                agentName,
                instance.meta.skillsPaths,
                { force: true, personal: true, cwd, skillName: skill.name }
              );
              
              for (const [skillName, targetResults] of result.skills) {
                for (const { target, result: installResult } of targetResults) {
                  if (installResult.success) {
                    printSuccess(`  ${agentName} (${target}): Installed ${skillName}`);
                    if (installResult.path) {
                      printInfo(`    Location: ${installResult.path}`);
                    }
                  } else {
                    printError(`  ${agentName}: Failed - ${installResult.error}`);
                  }
                }
              }
            }
          }
        } else {
          // Multiple agents selected - install all skills
          const result = await installSkillsForAgent(
            agentId,
            agentName,
            instance.meta.skillsPaths,
            { force: true, personal: true, cwd }
          );
          
          if (result.hasInstalls) {
            printSuccess(`  ${agentName}: Skills installed`);
          } else if (result.allSkipped) {
            printInfo(`  ${agentName}: Skills already up to date`);
          }
        }
        
        await instance.dispose();
      }
    } else if (bundledSkills.length === 0) {
      printInfo('No bundled skills available for installation.');
    }

    // === Save Configuration ===
    const answers: SetupAnswers = {
      tracker: selectedTracker,
      trackerOptions,
      agent: selectedAgent,
      agentOptions,
      maxIterations,
      autoCommit,
    };

    printSection('Saving Configuration');

    const configPath = await saveConfig(answers, cwd);

    console.log();
    printSuccess(`Configuration saved to: ${configPath}`);
    console.log();

    // === Verify Agent Configuration ===
    printSection('Verifying Agent Configuration');

    printInfo('Running agent preflight check...');
    console.log();

    // Get a fresh agent instance with the configured options
    const agentRegistry = getAgentRegistry();
    const agentInstance = await agentRegistry.getInstance({
      name: selectedAgent,
      plugin: selectedAgent,
      options: agentOptions,
    });

    // Run preflight check
    const preflightResult = await agentInstance.preflight({ timeout: 30000 });

    if (preflightResult.success) {
      printSuccess(`✓ Agent is configured correctly and responding`);
      if (preflightResult.durationMs) {
        printInfo(`  Response time: ${preflightResult.durationMs}ms`);
      }
      console.log();
    } else {
      printError(`✗ Agent preflight check failed`);
      if (preflightResult.error) {
        printError(`  ${preflightResult.error}`);
      }
      if (preflightResult.suggestion) {
        console.log();
        printInfo('Suggestions:');
        // Split suggestion by newlines and print each line
        for (const line of preflightResult.suggestion.split('\n')) {
          console.log(`  ${line}`);
        }
      }
      console.log();
      printInfo('Configuration saved, but the agent is not responding.');
      printInfo('Run "ralph-tui doctor" to diagnose issues.');
      console.log();
    }

    // Show tracker-specific instructions
    if (selectedTracker === 'json') {
      printInfo('You can now run Ralph TUI with:');
      console.log();
      console.log('  Create a PRD and tasks:        ralph-tui create-prd');
      console.log('  Run Ralph on existing tasks:   ralph-tui run --prd <path-to-prd.json>');
    } else {
      printInfo('You can now run Ralph TUI with:');
      console.log();
      console.log('  ralph-tui run');
    }
    console.log();
    printInfo('Or edit the configuration with:');
    console.log();
    console.log('  ralph-tui config show');
    console.log();

    return {
      success: true,
      answers,
      configPath,
    };
  } catch (error) {
    // Check for user cancellation (Ctrl+C)
    if (error instanceof Error && error.message.includes('readline was closed')) {
      console.log();
      printInfo('Setup cancelled.');
      return {
        success: false,
        cancelled: true,
      };
    }

    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * Check if setup is needed and optionally run the wizard
 */
export async function checkAndRunSetup(
  options: SetupOptions & { skipSetup?: boolean } = {}
): Promise<SetupResult | null> {
  const cwd = options.cwd ?? process.cwd();

  // Check if config exists
  const exists = await projectConfigExists(cwd);

  if (exists) {
    // Config exists, no setup needed
    return null;
  }

  if (options.skipSetup) {
    // User wants to skip setup
    printInfo('No configuration found. Run "ralph-tui setup" to create one.');
    return null;
  }

  // Run the wizard
  return runSetupWizard(options);
}
